{
  "title": "App Ajedrez",
  "description": "Una aplicación de ajedrez que he desarrollado por amor al juego. Esto comenzó por un reto de mi profesor de segundo año en la universidad, pues yo quería desarrollar un ajedrez como mi proyecto final pero él insistía que era un proyecto demasiado complejo para nuestro nivel en aquel momento. tras debatirlo por un rato, dijo que sólo podría hacerlo como proyecto final si era capaz de traer piezas funcionales para la siguiente clase, dentro de tres días. ¡Así que eso hice! Originalmente, este proyecto estaba hecho en HTML/JS vanilla, pero decidí implementar una versión del proyecto en nextjs porque me estaba costando entender algunos conceptos de react y nextjs, y si bien tuve que aprender MUCHO para poder hacer funcionar todo, este proyecto es de los que más orgulloso estoy al día de hoy. ¡Incluso estoy trabajando en desarrollar una IA para el! Échale un ojo si quieres aprender sobre todas las dificultades de un proyecto como éste.",
  "project": {
    "title": "App Ajedrez",
    "sections": [
      {
        "title": "El Comienzo",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "Este proyecto comenzó como un reto de mi profesor de segundo año de universidad. Yo quería crear una aplicación de ajedrez para mi trabajo final de la materia, pero él insistió en que sería demasiado difícil y muy por encima de lo que se esperaba de nosotros en ese momento. Así que, luego de mucho debate, acordamos que si podía llevar piezas funcionales (sin verificación de movimientos legales) a la siguiente clase, que era tres días después, podría asumir este proyecto como mi trabajo final. ¡Asi que eso hice! Este fue el comienzo de un hermoso, aunque arduo, camino. Aún era nuevo en muchos conceptos de programación, como tipos de referencia vs. tipos primitivos, copias superficiales de matrices bidimensionales, verificación y limitación de índices dinámicos, y muchos otros pasos como simular estados del tablero para varias reglas del ajedrez, que veremos más adelante. ¡Comenzemos!"
      },
      {
        "title": "The game",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "La forma en que elegí representar el tablero fue mediante una matriz bidimensional de 8x8, con valores de piezas comunes en notación de ajedrez. Por ejemplo un 1 es un peón blanco, -1 es un peón negro, 3 es un caballo, 4 es un alfil, 5 es una torre, 9 es una reina y le asigné un valor arbitrario de 8 al rey, ya que este no tiene valor de pieza propiamente dicho. La lógica de los movimientos fue bastante simple, ya que las piezas tienen un patrón determinado.\nLos peones se mueven verticalmente en una dirección según su color [+-1 o +-2, 0], mientras que los alfiles se mueven en diagonal; por ejemplo, [+-3, +-3] lo mueve 3 casillas hacia cualquier diagonal; siempre que haya un aumento igual en ambas coordenadas, debería ser una diagonal.\nLas torres pueden dejar su eje x o y estático y moverse a lo largo de la otra coordenada para lograr movimiento vertical u horizontal. Por ejemplo, [0, +-5] las mueve horizontalmente 5 casillas.\nLos caballos siempre combinan un 1 y un 2 en sus coordenadas correspondientes. Por ejemplo, [+-2, +-1] y, finalmente, una reina y un rey son simplemente una torre + un alfil. La reina tiene alcance ilimitado en el tablero y el rey está limitado a una casilla desde su posición. Bastante simple, ¿No? ¡Ajedrez listo! ... bueno, no del todo.\nAhora tenemos que empezar a aplicar las reglas del ajedrez, y hay un orden para implementarlas. Por ejemplo, si quisiéramos implementar la lógica del jaque mate, primero necesitaríamos saber que A: El rey está actualmente en jaque y B: No existe ningún movimiento legal que lleve a un estado de tablero donde el rey ya no esté en jaque. Por lo tanto, primero debemos comprender la lógica del jaque. Según la lógica de piezas que acabo de describir, cada pieza se comporta como un caballo, ya que pueden saltar sobre cualquier pieza del tablero (es decir, son superpiezas) y hasta pueden comer piezas del mismo color. Por lo tanto, primero debemos hacer que las piezas conozcan los límites de sus movimientos disponibles pues, como veremos, el ajedrez tiene muchas reglas."
      },
      {
        "title": "Lo Permitido y lo Prohibido",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "Queremos que nuestras piezas se comporten como en un ajedrez real, así que necesitamos establecer límites sobre lo que pueden y no pueden hacer. Primero, debemos abordar una excepción programática que aparecería usando solo la implementación anterior: asegurarnos de que agregamos movimientos dentro de los límites del tablero. Si simplemente intentamos escanear 8 casillas en cada dirección sin comprobaciones, eventualmente nos encontraremos con un error de indexación, ya que los arrays no contendrán índices menores que 0 ni mayores que 7 (ya que los arrays son indexados en 0), lo cual es bastante simple. El siguiente paso es verificar qué hay en el tablero para cada casilla que intentamos agregar a nuestros movimientos legales.\nEsto también es bastante simple: ninguna pieza puede moverse a una posición donde exista una pieza del mismo color, y ninguna pieza, excepto los caballos, puede saltar a otras piezas para moverse en algún lugar. Esto significa que debemos escanear si hay algo en cada dirección y, de haberlo, preguntar qué es. Si es una pieza de color opuesto, podemos capturarla (a menos que estemos comprobando lógica de capturas de peones, pero no nos adelantemos), así que añadimos ese movimiento como legal y rompemos el bucle en esa dirección. Si es del mismo color, rompemos el bucle sin añadirlo como movimiento legal. ¡Felicidades! Nuestras piezas ya no hacen trampa descaradamente... bueno, generalmente hablando."
      },
      {
        "title": "El Subcampeón de la Lógica de Pieza más Compleja: Peones",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "Si te gusta el ajedrez, probablemente no te hayas dado cuenta de lo arbitraria que es la lógica de los peones. Ninguna otra pieza puede capturar a otra en una dirección diferente a la que se mueve, ninguna otra pieza puede capturar a otra en una casilla donde no está (peón al paso), sus movimientos varían según si ya se ha movido o no, y lo más importante, ninguna otra pieza puede convertirse en una pieza completamente diferente. La lógica de peones ya añade una capa muy real de complejidad a la interfaz de usuario y refactorización de las estructuras, ya que ahora necesitamos poder comprobar si un peón ya se ha movido, si está junto a un peón que se movió específicamente por primera vez en el último turno, si pertenece al color contrario y si está horizontalmente adyacente al peón para el cual estas generando los movimientos.\nFinalmente, necesitas desglosar la actualización del estado del tablero en pasos para poder implementar una interfaz de usuario que elija a qué pieza puede promocionar un peón si alcanza la fila final de su dirección. Este paso intermedio será relevante más adelante, pero por ahora lo estaba codificando en HTML/JS/CSS básico, así que la modificación imperativa del DOM lo hizo mucho más fácil de lo que sería al trasladar este proyecto a un entorno con React. Dicho esto, y si bien fue un poco desafiante, la verdad es que no es para tanto. Alcanzar la clasificación final => Abrir el menú de promoción => actualizar tablero. Verificar capturas diagonales en lugar del movimiento normal como el resto de las piezas, cambiar el valor inicial del peón a +-2 para indicar que no se ha movido (actualizarlo a 1 si lo hace) y guardar los datos de la última pieza movida (qué era antes de moverse y adónde se movió). Si se trata de un peón de color opuesto adyacente horizontalmente [0, +-1], se puede capturar al paso."
      },
      {
        "title": "El Rey Está en Todos Lados",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "Ahora que hemos definido la lógica de cómo nuestras piezas generan movimientos legales, es hora de comprobar si realmente son legales. Si te parece confuso, no te preocupes. Lo que quiero decir es que el ajedrez tiene una regla que dice que el rey no puede quedar en jaque al finalizar tu movimiento, así que para una pieza, la legalidad de sus movimientos no depende completamente de su propia lógica de generación de estos. ¿Cómo puedes saber si el movimiento de una pieza pondría a tu rey en jaque? Si juegas al ajedrez sobre el tablero, observas las posibles diagonales o piezas que puedan ver la pieza que quieres mover e imaginas cómo se vería el tablero si esa pieza estuviese en otro lugar. ¡Y Esto es exactamente lo que vamos a hacer! Ya tenemos bien la lógica base de generación de movimientos, así que podemos comprobar qué ven las piezas enemigas. Sin embargo, implementar esto no es tan sencillo, así que tendrá su propia sección para explicarlo en detalle. \nAdemás de tomar parte en la legalidad de cada movimiento posible, ¡El Rey aparentemente también tiene superpoderes! Y por superpoderes me refiero a más reglas arbitrarias que no siguen la lógica a la que están sujetas las demás piezas. El rey puede enrocarse saltando sobre una torre y haciendo que esta también se mueva durante ese turno, obligando a dos piezas a mover a la vez, pero esto solo es posible si las piezas de color contrario no pueden ver ninguna parte del camino que el rey tendría que tomar para llegar allí, y además, el Rey y la torre con la que intenta enrocar no deben haberse movido previamente. Por suerte para nosotros, los peones ya nos han hecho resolver una parte de este problema antes, por lo que cambiamos el valor inicial de las Torres a +-6 y lo actualizamos a +-5 una vez que se han movido, y asignamos +-10 al rey ya que el 9 ya lo tiene asignado la reina. De esta forma, al menos ahora podemos comprobar si hay alguna pieza en el camino entre el Rey y sus Torres, así como saber si se han movido o no previamente."
      },
      {
        "title": "El Ajedrez es una Simulación. Varias, de hecho.",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "Para esta instancia imaginar un tablero real no servirá de mucho, ya que ahora tenemos que averiguar cómo hacer que una computadora compruebe si un movimiento pondría al rey en jaque, además de saber qué ven exactamente las piezas enemigas en diferentes puntos. Recapitulemos los problemas que aún presenta nuestra aplicación: no sabemos si el rey está en jaque, no sabemos si un movimiento es legal y no podemos comprobar la lógica de enroque ilegal. Para solucionar esto, debemos inspirarnos en Matrix y adoptar la simulación. ¿No sabes si el movimiento de una pieza pondrá al rey en jaque? ¡Simplemente emula un estado del tablero donde esa pieza no exista! Esto requerirá una ligera refactorización en la lógica de las piezas para que sepan si estamos emulando estados del tablero o no, de modo que podamos activar las simulaciones cuando un usuario haga clic en una pieza, pero evitando un bucle recursivo infinito si comprobamos estados de tablero emulados. Así que indicamos que estamos emulando tableros, almacenamos el estado real del tablero, retiramos la pieza en la que se hizo clic de nuestro tablero emulado y generamos todos los movimientos legales que nuestro oponente podría realizar en dicho tablero. Si las coordenadas de nuestro rey coinciden con los movimientos legales de una de las piezas contrarias, entonces puede ser capturado, o en otras palabras, está en jaque. ¡Por lo tanto, sabemos que este movimiento es ilegal! ...bueno, nuevamente, no exactamente.\nMover una pieza puede ser ilegal en algunas direcciones, pero legal en otras: una torre puede estar mirando a una reina que esconde a su rey, pero si simplemente simulamos que la reina no está, nuestro programa creerá que cualquier movimiento de la reina es ilegal, cuando en realidad debería poder moverse por la misma línea de la torre que la mira, o incluso capturarla. Por ende, si bien este enfoque introduce el concepto de emular estados alternativos del tablero donde nuestras piezas están posicionadas de forma diferente y generan los movimientos del oponente, no es la forma correcta de resolver nuestro problema.\n Entonces, si no simulamos retirarla, ¿qué pasa si simulamos todos sus movimientos? ¡Esto es mucho mejor! Incluso podemos optimizar ligeramente la simulación de estados del tablero si vemos que mover una pieza en cierta dirección haría que el rey estuviera en jaque, ya que no hay ningún caso en el que moverse en diagonal, horizontal o verticalmente a lo largo de un eje haga que el rey esté en jaque después de avanzar un casillero y deje de estarlo luego de avanzar más por esa línea. Sin embargo, decidí no aplicar esta optimización ya que pensé que podría ser divertido implementar nuevas piezas fuera del ajedrez tradicional donde podría darse este caso.\n¡Genial! Ahora podemos emular el estado del tablero para cada movimiento que una pieza podría realizar si no preguntamos en que anda el rey.\nSolo queda almacenar los movimientos que causan tableros donde el rey no estaría en jaque, ¡Y listo! Esta es nuestra validación de movimientos legales para la generación de movimientos. Solo queda usar la misma lógica de emulación para registrar las casillas que controlan las piezas rivales y comprobar si ven una casilla en el camino de enroque. ¡Esto también permite implementar la lógica de jaque mate y ahogado! Solo tenemos que, usando nuestra nueva lógica de emulación, comprobar si, tras un movimiento, las piezas cuyo turno sería ahora tienen movimientos legales disponibles, y si la respuesta es no, comprobar si el rey está en jaque. Si está en jaque y no hay movimientos legales, la partida termina con victoria por jaque mate, y si el Rey no está en jaque pero no tiene movimientos legales, la partida termina con empate por ahogamiento."
      },
      {
        "title": "Aprendiendo sobre UI Reactiva",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "Ya completada la lógica del juego, sólo nos queda implementar una interfaz visual adecuada, ya que nadie quiere jugar a un ajedrez feo. Esto es bastante sencillo en HTML/CSS/JS vanilla, y donde di por terminado el proyecto para mi trabajo final de segundo año de programación. Creé un par de relojes de ajedrez, implementé botones de empate y rendirse, me fui a casa con un sólido 9 en mi proyecto (existe una pequeña posibilidad de que haya olvidado incluir una función simple que formaba parte del trabajo) y di por cerrado el proyecto.\nSin embargo, este no es el final de esta historia. Resulta que el año siguiente aprendimos sobre Node.js y React, junto con un metaframework de React llamado NextJS. Esto incorporó muchos conceptos nuevos de repente, y como estaba teniendo dificultades con muchos de ellos, decidí hacer lo mejor que se puede hacer para realmente aprender algo: intentar completar un proyecto que está MUY por encima de tu capacidad actual. Decir que me costó aprender sobre estado reactivo, hidratación, generación estática de sitios renderización en servidor, ganchos y un nuevo conjunto de herramientas de depuración sería quedarse corto. Yo necesito realmente entender un concepto antes de intentar implementarlo, y nuestro tercer año de universidad se centró más en aprender conceptos generales copiando y haciendo que en explicar las tecnologías con las que trabajábamos en profundidad. \nEsto simplemente no me sirvió. \nNecesitaba aprender más. \nA decir verdad, mentiría si dijera que hoy entiendo completamente todo lo que React o los metaframeworks de React utilizan para mejorar tanto el desarrollo como el rendimiento, pero lo que sí puedo decir es que definitivamente aprendí mucho al respecto. Mi enfoque inicial para crear un proyecto de ajedrez basado en estados reactivos fue simplemente tener un array bidimensional reactivo y dejar que las actualizaciones de React gestionaran el movimiento visual de los componentes. Este fue un camino complicado, ya que tuve que reaprender cuándo realizar comprobaciones del estado del tablero, ya que las actualizaciones del estado de los ganchos no son inmediatas. Esto fue especialmente complicado al implementar la promoción, ya que tuve que cambiar mi enfoque: de simplemente dejar que la naturaleza sincrónica de JavaScript hiciera que el usuario seleccionara una pieza y solo entonces volviera a la partida, ahora necesitaba actualizar un estado independiente que gestionara la representación de la interfaz de usuario de la promoción y que luego llamara a la función de actualización principal con un evento especial, avisando al componente del tablero para que actualizara esa pieza a un valor diferente.\nTodo esto me llevó mucho tiempo y trabajo, pero lo logré. Sin embargo, a medida que evolucioné como programador, me di cuenta de que esta versión de la aplicación no era suficiente para cumplir con mis estándares. Quería animaciones, quería sonido, quería una experiencia de usuario más dinámica. Quería más."
      },
      {
        "title": "Animaciones y Fuentes de Verdad",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "Esta es, sin duda y sin ninguna competencia, la parte que más me obligó a refactorizar mi código. El principal problema al pasar de JavaScript puro a un framework es que, cuando solo tienes un martillo, todo parece un clavo. Me acostumbré al manejo imperativo del DOM de JavaScript y me costó mucho comprender la separación de las fuentes de verdad para el estado lógico del juego y el estado visual. Esto me obligó a refactorizar a fondo la lógica de renderizado de las piezas, así como a desarrollar fórmulas matemáticas para alinearlas correctamente en su contenedor, ya que cada cuadrado ya no renderizaba directamente su contenido. Las casillas seguirían teniendo la lógica de clic, pero las piezas se actualizarían visualmente de forma independiente de la matriz del juego. Probablemente parezca extraño que describa esto como la parte con la que más me costó durante el proceso de creación de este proyecto y al mismo tiempo no tener mucho más que decir al respecto, pero es la verdad: a veces nos cuesta más con algo por un bloqueo mental o una predisposición personal que por una complejidad lógica inherente. Logré descifrarlo, animar mis piezas, separar la lógica del juego de la visual y crear un tablero de ajedrez genial (en mi opinión) que me ayudó a aprender mucho sobre programación, que es algo que me fascina y tengo muchas esperanzas de que cambie mi vida."
      },
      {
        "title": "¿Qué Sigue?",
        "reference": {
          "url": "",
          "alt": "",
          "code": ""
        },
        "description": "Ahora que tengo un hermoso tablero funcional, quiero probar meterme en el mundo del ajedrez PvP online en tiempo real usando websockets, así como en el maravilloso mundo de la IA. De hecho, ¡Este es uno de mis proyectos personales en el que estoy trabajando activamente ahora mismo! Esten atentos a esta página, porque les aseguro que aún no he terminado con este proyecto."
      }
    ],
    "conclusion": "Este proyecto fue muy divertido. También me causó mucha frustración, estrés y tirones de pelo, pero así es la vida. Programar no es fácil; si lo fuese, a nadie le importarían los desarrolladores de software, y mucho menos contratarían a uno. Esto comenzó como un proyecto pasional y me alegro mucho de haber perseverado hasta terminarlo. Hubiese sido fácil rendirse, pero rendirse no solo elimina el estrés y la frustración, sino que también te quita todo lo que aprenderías al realizar un proyecto. Te despoja de un proceso maravilloso y de la satisfacción de poder terminar un proyecto desafiante. Sinceramente, amo el hecho de haberlo terminado, y pretendo seguir mejorando. Tanto el proyecto como a mí mismo como programador. Si has llegado hasta aquí, ¡Gracias por leer! Espero que este artículo te haya resultado entretenido, e incluso educativo o motivador. ¡Nos vemos!"
  }
}
